{"meta":{"title":"Lei Cai's Blog","subtitle":null,"description":null,"author":"Lei Cai","url":"https://smartlei24.github.io","root":"/"},"pages":[],"posts":[{"title":"从 REST 到 GraphQL","slug":"architecture/从 REST 到 GraphQL","date":"2019-10-25T09:43:13.382Z","updated":"2019-10-25T09:43:40.375Z","comments":true,"path":"2019/10/25/architecture/从 REST 到 GraphQL/","link":"","permalink":"https://smartlei24.github.io/2019/10/25/architecture/从 REST 到 GraphQL/","excerpt":"","text":"从 REST 到 GraphQL名词解释REST指 B/S 开发界无人不知的 RESTful API，它是一种 API 的设计风格：URL定位资源，用HTTP动词（GET,POST,PUT,DELETE）描述操作。详细内容可参考阮一峰老师的文章RESTful API 设计指南 比如获取班级 A 中学生 B 的的信息： GET /class/a/student?name=b GraphQL首先是一种查询语言（QL == Query Language），从字面上看它应该是和 SQL 是同一级别的东西，其实确实可以这么认为，毕竟两者都主要是为了查询数据而设计，只是 GraphQL 的抽象更高，并且面向的不是数据库而是 API。 从 GraphQL 中的 Graph 这个单词中我们也可以看出，它是和图论是有一定关系的，如果把所有对象都看作一个节点，把各个节点之间的关系看作边，那最终就会组成一张图，我们可以从一个节点出发，通过节点之间的联系，到达其他节点，获取其信息。GraphQL 描述如何去通过这张图获取需要的信息的查询语言，具体就是将路径通过一种类似 JSON 的格式表现出来 。 比如上例查询班级 A 中学生 B 的年龄和性别，就可以通过 GET 方法以以下内容发送请求（当然是在 query string里，而非body中） GET /grahpql 12345678query &#123; class(id=A) &#123; students(name=&quot;B&quot;) &#123; age gender &#125; &#125;&#125; 为什么要用 GraphQL？软件行业的前辈曾说过学一门新技术的兴起一定是为了解决一些现有的问题，我们在学习这门新技术之前，也应当先搞清楚这门技术到底解决了什么问题。 首先我们先来聊聊现有的 RESTful API，这两年 REST 真可谓是大行其道，无处不见其身影，自我刚参加工作就接受了它的“洗脑”，一直都是它的铁杆粉丝。平时看到哪个 API 没有遵守 RESTful API 规范，心里都是暗暗的一阵鄙视。为什么 RESTful API 能受到大家如此的推崇呢？我想最主要的就是因为它的定义清晰，规则简单，可读性很强，和 HTTP 协议的结合也是十分完美。我们能够很容易地从一条 API 的 URL 得出这条 API 的用途和它的输入和大概返回信息，再加上一些自动化的文档工具，大大程度上减少了前后端沟通的成本。 但是，RESTful API 并不是完美的，其最大的弊端在于 前端和后端之间并没有实现所谓的“高内聚，低耦合”。理想情况下，在 API 设计阶段我们都希望根据领域建模做好设计，做到每个 API 都整洁直观可复用，最后前端再通过相对应的 API 进行组合调用实现功能。 但实际上能做到如此的少之又少，最终我们往往都因为一些前端功能的变动（一般来讲也就是需求的变动）就修改已存在 API，再有甚者，不得不另外再造一个差不多的 API，到后来 API 越来越多，造成 “API 爆炸”。以至于前端功能（需求）的变动往往都会导致后端的变动和增加重复内容。 比如，我们已有一个 API (/class/students) 获取班级中的所有同学的学号，现在需求变了，前端需要这些同学的姓名，性别等信息，并且因为考虑到性能，当然不能让前端拿到学号之后再一个一个的去查同学的信息，这时就只有两种方案： 直接改 API，使之从返回一个 number 数组，改变为返回一个 Object 数组 考虑到这个 API 目前已经有很多其他地方在用了，只能另外建一个新 API：/class/students-detail 用来满足需求 无论哪种方案我们都需要对后端的 API 设计进行改动，其直接原因就是 API 的设计直接依赖于需求（大多数时候体现就是前端功能），而需求则是难以预测和琐碎的，这就导致 API 的最终实现很难与最开始设计的一致。而 GraphQL 就是来解决这一问题的：降低前后端之间的耦合，让两者都专注的做自己的事情。 GraphQL 如何解决问题简而言之，GraphQL 就是提供了一个唯一的 API，任何数据访问都直接通过这个 API，这个 API 与任何单一的业务逻辑和需求无关，只是作为一个服务的入口。前端通过这个 API 告诉后端，我需要哪些数据，以及这些数据的格式、结构，后端根据前端的请求直接返回对应的数据，这样数据内容、结构都是由前端的请求决定的，如此一来后端 API 便不需要因为前端的变更而频繁的变动，也不用担心会影响到旧 API 。 上面说过通过 GraphQL 可以降低前后端之间的耦合，让两者都可以专注做自己的事情，让前端专注功能和需求功能，让后端专注模型的建立。 在一定程度上，我们可以直接把后端看作是为前端提供数据的（类似数据库一样的东西）。如果用过 ORM（比如 EF） 的同学，在实现 GraphQL 形式的后端服务时可能会感到很熟悉，因为两者的一部分工作都建立在建立对象关系模型上，在忽略某些其他情况下（如权限控制），我们此时可以将后端看作一个对外的 ORM，我们通过 GraphQL 与其交互，得到我们期望的结果。 这里我们通过两个例子来说明简单的 GraphQL 使用： 查询 A 班级中所有姓名为 B 的学生的年龄及性别： 12345678query &#123; class(id=A) &#123; students(name=&quot;B&quot;) &#123; age gender &#125; &#125;&#125; 反过来查询所有姓名为 B 的学生的班级序号 12345query &#123; students(name=&quot;B&quot;) &#123; classId &#125;&#125; 上面两个原先需要另外写的 API，通过 Graphql 就直接通过 GraphQL 解决了，只要对象建模没有问题，就无需修改后端，相比 RESTful API 的设计灵活的多，还是很方便的。 总结后端不想总是改接口或新增接口，请使用 GraphQL 前端不想总是要等后端改接口，也请使用 GraphQL","categories":[{"name":"architecture","slug":"architecture","permalink":"https://smartlei24.github.io/categories/architecture/"}],"tags":[]},{"title":"从一道题来看 C# 的方法调用","slug":"dotnet/call_method","date":"2019-10-25T09:41:36.288Z","updated":"2019-10-25T09:41:36.288Z","comments":true,"path":"2019/10/25/dotnet/call_method/","link":"","permalink":"https://smartlei24.github.io/2019/10/25/dotnet/call_method/","excerpt":"","text":"在网上看到一道 C# 的题，比较有趣，因此记录一下。 以下是一个控制台程序，请问输出结果是？ 1234567891011121314151617181920212223using System; public class Program&#123; class Base &#123; public Base() &#123; Func(); &#125; public virtual void Func() &#123; Console.WriteLine(\"Base.Func\"); &#125; &#125; class Sub : Base &#123; public Sub() &#123; Func(); &#125; public override void Func() &#123; Console.WriteLine(\"Sub.Func\"); &#125; &#125; public static void Main() &#123; Base obj = new Sub(); obj.Func(); &#125;&#125; 可以先思考一下，写出自己的答案再往下读。 这里考察了两个知识点：第一： 构造函数的调用顺序第二： 虚函数的调用 首先我们先来回忆一下构造函数的调用:如果派生类的构造器没有显式调用一个基类的构造器，C# 编译器会自动生成对基类的默认构造器的调用。关于这一点，我们可以查看 Base 类和 Sub 类的编译的构造函数的 IL 代码得出。 Base 类直接直接继承于 Object, 因此它的构造函数中会调用 Object 的构造函数。Sub 类继承 Base 类， 因此它的构造函数中会调用 Base 的默认构造函数。 因此我们可以得出 Func 这个函数的调用顺序： Base 构造函数中的 Func 调用 → Sub 的构造函数中的 Func 调用 → Main 函数中 Func 调用 再来看 Func 函数的每次调用的效果。 《CLR via C#》 一书中提到，CLR 提供两个方法调用指令，分别是 call 和 callvirt。 call 指令可以用于调用 静态方法 和 实例方法 和 虚方法 ，call 指令使用变量自身的类型作为方法的定义类型，因此假设 Base a = new Sub(); 如果使用 call 指令来调用 a.Func(); 的话，因为变量 a 是 Base 类型，输出结果应当是：”Base.Func”。 callvirt 指令可以用于调用 实例方法 和 虚方法，当使用 callvirt 指令调用非虚实例方法时，callvirt 使用变量自身类型作为方法的定义类型。而当 callvirt 指令调用虚方法时，CLR 会调查调用对象的实际类型，然后使用多态的方式调用。并且因为需要调查变量指向的对象的实际类型，callvirt 需要检查变量是否为 null，若是 null 则会抛出 NullReferenceException。即 Base a = new Sub(); 当使用 callvirt 调用 a.Func 时，因为 a 的实际类型是 Sub,且 Func 是一个虚函数，因此将输出： “Sub.Func”。 那么 C# 编译器什么时候会使用 call， 而什么时候又使用 callvirt 呢？ 总结下来，在一般情况下，静态方法以及值类型的实例方法使用 call， 而引用类型的实例方法使用 callvirt。这就是为什么在引用类型为 null 时调用方法总是会抛出运行时异常 NullReferenceException（如下面一段代码），因为在 C# 编译器中对于引用类型的实例方法总是用 callvirt 调用。 12Base a = null;a.Func(); 而在其他 .Net 的编程语言中，以上代码的类似代码可能会正常工作，并输出 “Base.Func”。 再回到我们原题上来， “Base obj = new Sub();” 因为此处 Func 是虚函数，因此会根据变量的实际类型来确定调用哪个函数，而这里因为是 Sub 的实例，所以 this 指向的当前实例的实际类型一直都是 Sub 类型，同理变量 obj 的实际类型也是 Sub，因此最终输出结果就是三个 Sub.Func： Sub.FuncSub.FuncSub.Func 怎么样？ 你做对了吗？那如果不是虚方法，而使用 new 覆盖呢？ 1234567891011121314151617181920212223using System; public class Program&#123; class Base &#123; public Base() &#123; Func(); &#125; public void Func() &#123; Console.WriteLine(\"Base.Func\"); &#125; &#125; class Sub : Base &#123; public Sub() &#123; Func(); &#125; public new void Func() &#123; Console.WriteLine(\"Sub.Func\"); &#125; &#125; public static void Main() &#123; Base obj = new Sub(); obj.Func(); &#125;&#125;","categories":[{"name":"dotnet","slug":"dotnet","permalink":"https://smartlei24.github.io/categories/dotnet/"}],"tags":[]},{"title":"HTTP 状态码","slug":"http/http-status-code","date":"2019-10-25T09:41:36.288Z","updated":"2019-10-25T09:41:36.288Z","comments":true,"path":"2019/10/25/http/http-status-code/","link":"","permalink":"https://smartlei24.github.io/2019/10/25/http/http-status-code/","excerpt":"","text":"HTTP 状态码描述服务器端的处理结果，借助状态码，用户可知服务器端是否正常处理了请求，还是出现了错误。 HTTP 状态码的组成以三位数字和原因短语组成，数字的第一位指定了响应类别，可分为以下五种： 状态码 类别 原因短语 1xx 信息性状态码 接受的请求正在处理 2xx 成功 正常处理完毕 3xx 重定向 需要进行附加操作以完成请求 4xx 客户端错误 服务器无法处理请求 5xx 服务端错误 服务器处理请求出错 我们既可以使用 RFC 标准定义的状态码，也可以根据我们的需求自行创建状态码，但最好遵守以上类别，因为浏览器和一些应用（如MQ）中会依此来判断请求处理的结果。接下来我们分别介绍一下常用的的 HTTP 状态码： 状态码 短语 含义 200 OK 客户端的请求服务器端正常处理完了 204 NO Content 服务器正常处理完，但没有资源可返回 206 Partial Content 表示对范围请求的成功响应 301 Moved Permanently 永久重定向，表示请求的资源已被分配了新的 URI，意味着可能需要更新书签之类的 302 Found 临时重定向，仅仅本次重定向，下次还是访问此 URI 303 See Other 同 302 ，但按标准会使用 GET 请求访问新的 URI，但实际上几乎所有浏览器响应 301/302 也都会改用 GET 304 Not Modified 服务器运行请求访问资源，但因不满足请求的附带条件而直接放回304，常用于服务端资源未改变，客户端可直接使用未过期的缓存 307 Temporary Redirect 临时重定向，但遵从标准，不会改变请求方法为 GET 400 Bad Request 请求报文中存在语法错误 401 Unauthorized 表示请求需要通过 HTTP 认证 403 Forbidden 表示服务器拒绝请求对资源的访问，常用于无权限的情况 404 Not Found 表示服务器无法找到请求的资源 500 Internal Server Error 表示服务端在执行请求时发生了错误，可能是出现了bug 或一些临时故障 503 Service Unavailable 表示服务端暂时处于超负载或正在进行停机维护，暂时无法处理请求，可在头部加上 RetryAfter 字段建议多长时间后再尝试","categories":[{"name":"http","slug":"http","permalink":"https://smartlei24.github.io/categories/http/"}],"tags":[]},{"title":"集成 Sonarqube","slug":"ci/sonarqube-integrated","date":"2019-10-25T09:41:36.288Z","updated":"2019-10-25T09:41:36.288Z","comments":true,"path":"2019/10/25/ci/sonarqube-integrated/","link":"","permalink":"https://smartlei24.github.io/2019/10/25/ci/sonarqube-integrated/","excerpt":"","text":"SonarqubeSonarQube（曾用名Sonar（声纳）[1]）是一个开源的代码质量管理系统。 支持超过25种编程语言[2]：Java、C/C++、C#、PHP、Flex、Groovy、JavaScript、Python、PL/SQL、COBOL等。（不过有些是商业软件插件） 提供重复代码、编码标准、单元测试、代码覆盖率、代码复杂度、潜在Bug、注释和软件设计报告 提供了完全自动化的分析：与Maven、Ant、Gradle和持续集成工具 以上是来自维基百科的介绍，简而言之，我们能够基此平台对我们的工作提供一些帮助和决策支持，我们还可以基于此做一些自定义的优化。 Sonarqube 官网 官方文档 Sonar-gitlab-plugingithub地址：https://github.com/gabrie-allaigre/sonar-gitlab-plugin 我们项目组一直都在做 Code Review ，借助这个插件，可以将 sonarqube 的分析结果将 sonarqube 分析的结果以评论的方式添加至 gitlab，打破 sonarqube 和 gitlab 之间的信息阻隔，可作为 code review 的辅助信息，并借助 gitlab 评论的邮件通知将分析出来的问题通知作者，以下是其效果。 对 Commit 的总结评论： 对某行的具体评论： 实现方式为达到 commit 后自动触发流程，推荐使用gitlab-ci： 在项目的根目录下新建.gitlab-ci.yml文件 填入 CI 脚本 commit 后上传至gitlab 等待 CI 执行完出分析结果 这里我们以 前端项目的脚本为例 脚本案例这里我们以 NC3 前端项目为例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364stages: - testimage: swustlc/gitlab-sonar-scanner-typescriptvariables: SONAR_URL: \"sonarqube_server_url\" SONAR_LOGIN: \"user_login_token\" SONAR_SOURCE: \"src/modules\" TSLINT_CONFIG: \"tsconfig.json\" TSLINT_REPORT_JSON: \"report.json\".script-analysis-develop: &amp;script-analysis-develop | sonar-scanner \\ -Dsonar.host.url=$&#123;SONAR_URL&#125; \\ -Dsonar.login=$&#123;SONAR_LOGIN&#125; \\ -Dsonar.sources=$&#123;SONAR_SOURCE&#125; \\ -Dsonar.projectKey=$&#123;CI_PROJECT_NAME&#125; \\ -Dsonar.gitlab.project_id=$&#123;CI_PROJECT_ID&#125; \\ -Dsonar.gitlab.commit_sha=$&#123;CI_COMMIT_SHA&#125; \\ -Dsonar.gitlab.ref_name=$&#123;CI_COMMIT_REF_NAME&#125; \\ -Dsonar.gitlab.json_mode=CODECLIMATE \\ -Dsonar.gitlab.failure_notification_mode=commit-status \\ -Dsonar.sourceEncoding=UTF-8 \\ -Dsonar.ts.tslint.configPath=$&#123;TSLINT_CONFIG&#125; \\ -Dsonar.typescript.tslint.reportPaths=$&#123;TSLINT_REPORT_JSON&#125;.script-analysis-preview: &amp;script-analysis-preview | sonar-scanner \\ -Dsonar.host.url=$&#123;SONAR_URL&#125; \\ -Dsonar.login=$&#123;SONAR_LOGIN&#125; \\ -Dsonar.sources=$&#123;SONAR_SOURCE&#125; \\ -Dsonar.projectKey=$&#123;CI_PROJECT_NAME&#125; \\ -Dsonar.analysis.mode=preview \\ -Dsonar.gitlab.project_id=$&#123;CI_PROJECT_ID&#125; \\ -Dsonar.gitlab.commit_sha=$&#123;CI_COMMIT_SHA&#125; \\ -Dsonar.gitlab.ref_name=$&#123;CI_COMMIT_REF_NAME&#125; \\ -Dsonar.gitlab.json_mode=CODECLIMATE \\ -Dsonar.gitlab.failure_notification_mode=commit-status \\ -Dsonar.sourceEncoding=UTF-8 \\ -Dsonar.ts.tslint.configPath=$&#123;TSLINT_CONFIG&#125; \\ -Dsonar.typescript.tslint.reportPaths=$&#123;TSLINT_REPORT_JSON&#125;sonarqube_develop_job: stage: test only: - develop script: - tslint --force --format json --config tslint.json --out $&#123;TSLINT_REPORT_JSON&#125; --project ./ - *script-analysis-developsonarqube_preview_feature_job: stage: test except: - master - release - develop script: - git config --global user.name \"User\" - git config --global user.email \"User@company.com\" - git checkout origin/develop - git merge $CI_COMMIT_SHA --no-commit --no-ff -v - tslint --force --format json --config tslint.json --out $&#123;TSLINT_REPORT_JSON&#125; --project ./ - *script-analysis-preview 脚本主要内容主要可分为两个Job: 默认分支Job即脚本中 sonarqube_develop_job，该 Job 更新 sonarqube server 对应项目的情况，执行完成后可以登陆 https://sonar-server/dashboard?id={git-project-name} 查看当前项目的情况，如 https://sonar-server/dashboard?id=test-project。 我们这里使用的是 develop 分支作为对应分支，only: - develop 即在指定触发该job的分支，可根据自己使用情况修改。 feature 分支Job即脚本中 sonarqube_preview_feature_job，该 Job 不更新 sonarqube server 上项目的状况，相比默认分支Job,它的任务是预览 (参数： -Dsonar.analysis.mode=preview )。它先比较当前分支和默认分支的差异，将分析出的结果作为新的 issue，再反馈到 gitlab上。若 sonarqube service 上该项目不存在，所有问题都将认为是新issue。 参数列表 参数名 含义 -Dsonar.host.url=${SONAR_URL} sonarqube server 地址 -Dsonar.login=${SONAR_LOGIN} 登陆的 Token，可在 sonarqube / my count / security 生成 -Dsonar.analysis.mode=preview 分析模式 publish/preview， 默认：publish -Dsonar.sources=${SONAR_SOURCE} 分析文件的基地址，此处项目路径为 src/modules，可根据自己情况修改 -Dsonar.projectKey=${CI_PROJECT_NAME} 项目名，即指定 sonarqube server 上生成项目的项目名，此处使用gitlab上项目名称 -Dsonar.gitlab.project_id=${CI_PROJECT_ID} gitlab 项目标识符，用于插件标识 gitlab 项目，建议不要更改 -Dsonar.gitlab.commit_sha=${CI_COMMIT_SHA} commit标识符，用于插件标记本次 commit -Dsonar.ts.tslint.configPath=${TSLINT_CONFIG} TsLint 配置文件的路径 -Dsonar.typescript.tslint.reportPaths=${TSLINT_REPORT_JSON} TsLint 分析导出结果路径，配合 tslint –out {path} 命令使用 关于单元测试以上脚本没有包含 typescript 的单元测试相关的内容（镜像满足跑单元测试条件），若有需要可参考 TypeScript Test Execution and Coverage Results Import。 关于镜像需要一个具备 Jre，Sonarscanner, Node， Typescript，TSLint 环境的镜像，这里的脚本已提供满足条件的镜像，如有特殊需求，可以自行 build。 其他类型项目脚本最后附上一份 dotnet core 的脚本，包含单元测试，可修改 UNIT_TEST_COVERAGE 和 COVERAGE_INCLUDE 指定单元测试的目标覆盖率和包含文件，可参考Code Coverage Results Import (C#, VB.NET)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475stages: - testimage: swustlc/gitlab-sonar-scanner-dotnet-corevariables: SONAR_URL: \"https://sonar.newegg.org\" SONAR_LOGIN: \"e812dc208eac74f45ec0401414e4ed3a9f9a144d\" UNIT_TEST_COVERAGE: 0 COVERAGE_INCLUDE: \"[*.Domain]*.Rules.*\".run-unit-test: &amp;run-unit-test | dotnet test \\ /p:CollectCoverage=true \\ /p:CoverletOutputFormat=opencover \\ /p:Include=$COVERAGE_INCLUDE \\ /p:Threshold=$UNIT_TEST_COVERAGE \\ /p:ThresholdType=line \\ /p:ThresholdStat=average.sonar-scanner-preview: &amp;sonar-scanner-preview | dotnet-sonarscanner begin \\ /k:$CI_PROJECT_NAME \\ /d:sonar.host.url=$SONAR_URL \\ /d:sonar.login=$SONAR_LOGIN \\ /d:sonar.analysis.mode=preview \\ /d:sonar.gitlab.project_id=$CI_PROJECT_ID \\ /d:sonar.gitlab.commit_sha=$CI_COMMIT_SHA \\ /d:sonar.gitlab.ref_name=$CI_COMMIT_REF_NAME \\ /d:sonar.gitlab.json_mode=CODECLIMATE \\ /d:sonar.gitlab.failure_notification_mode=commit-status \\ /d:sonar.sourceEncoding=UTF-8 \\ /d:sonar.cs.opencover.reportsPaths=\"**\\coverage.opencover.xml\" dotnet msbuild -restore -target:Build -clp:ErrorsOnly dotnet-sonarscanner end /d:sonar.login=$SONAR_LOGIN.sonar-scanner-publish: &amp;sonar-scanner-publish | dotnet-sonarscanner begin \\ /k:$CI_PROJECT_NAME \\ /d:sonar.host.url=$SONAR_URL \\ /d:sonar.login=$SONAR_LOGIN \\ /d:sonar.analysis.mode=publish \\ /d:sonar.gitlab.project_id=$CI_PROJECT_ID \\ /d:sonar.gitlab.commit_sha=$CI_COMMIT_SHA \\ /d:sonar.gitlab.ref_name=$CI_COMMIT_REF_NAME \\ /d:sonar.gitlab.json_mode=CODECLIMATE \\ /d:sonar.gitlab.failure_notification_mode=commit-status \\ /d:sonar.sourceEncoding=UTF-8 \\ /d:sonar.cs.opencover.reportsPaths=\"**\\coverage.opencover.xml\" dotnet msbuild -restore -target:Build -clp:ErrorsOnly dotnet-sonarscanner end /d:sonar.login=$SONAR_LOGINsonarqube_publish_develop_job: stage: test only: - develop script: - dotnet restore - *run-unit-test - *sonar-scanner-publishsonarqube_preview_feature_job: stage: test except: - master - release - develop script: - git config --global user.name \"User\" - git config --global user.email \"User@company.com\" - git checkout origin/develop - git merge $CI_COMMIT_SHA --no-commit --no-ff -v - dotnet restore - *run-unit-test - *sonar-scanner-preview 给 Gitlab 项目添加 Sonarqube Badges我们可以借助 sonarqube 生成的徽章，添加到 Gitlab 对应项目上去，这样一进入项目主页就可以看到项目分析的状况。操作流程比较简单，如下： 点击在 sonarqube 对应项目的主页的右下角的 “Get project badges” 在弹出窗内选择要分析类型，如 Quantity Gate Status (是否通过设置的质量阀门)，复制链接 在 Gitlab 项目 / Setting / General / Badges 依次填入 点击跳转地址 和 图片地址（刚刚复制的） 将需要的徽章都添加进入后，即可在项目主页看到项目的分析状况，点击即可跳转到指定页面","categories":[{"name":"ci","slug":"ci","permalink":"https://smartlei24.github.io/categories/ci/"}],"tags":[]}]}